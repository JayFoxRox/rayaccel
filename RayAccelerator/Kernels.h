//
//  Kernels.h
//  RayAccelerator
//
//  Created by Rasmus Barringer on 2014-02-27.
//  Copyright (c) 2014 Rasmus Barringer, Tomas Akenine-MÃ¶ller, and Magnus Andersson. All rights reserved.
//

static const char traversalKernel[] =
"\n"
"#ifdef WIN32\n"
"inline float2 make_float2(float x, float y) {\n"
"	return (float2){ x, y };\n"
"}\n"
"inline float3 make_float3(float x, float y, float z) {\n"
"	return (float3){ x, y, z };\n"
"}\n"
"inline float4 make_float4(float x, float y, float z, float w) {\n"
"	return (float4){ x, y, z, w };\n"
"}\n"
"#endif\n"
"\n"
"inline float3 mad_cross(float3 e1, float3 e2) {\n"
"	return make_float3(mad(e1.y,e2.z, -e1.z*e2.y), mad(e1.z,e2.x, -e1.x*e2.z), mad(e1.x,e2.y, -e1.y*e2.x));\n"
"}\n"
"\n"
"#define RAY_ORIGIN(ray) ray.xyz\n"
"#define RAY_DIRECTION(ray) ray.s456\n"
"#define RAY_NEAR(ray) ray.w\n"
"#define RAY_FAR(ray) ray.s7\n"
"\n"
"#ifndef WORK_GROUP\n"
"#define WORK_GROUP 32\n"
"#endif\n"
"\n"
"inline float trianglePairIntersect(global float4* triangles, int index, float8 ray, float4* hit) {\n"
"	float4 t0 = triangles[index*3+0];\n"
"	float4 t1 = triangles[index*3+1];\n"
"	float4 t2 = triangles[index*3+2];\n"
"	\n"
"	float tNear = RAY_NEAR(ray);\n"
"	float tMax = RAY_FAR(ray);\n"
"	float3 ro = RAY_ORIGIN(ray);\n"
"	float3 rd = RAY_DIRECTION(ray);\n"
"	\n"
"	float3 e1 = t0.xyz;\n"
"	float3 e2 = t1.xyz;\n"
"	float3 e3 = make_float3(t0.w, t1.w, t2.w);\n"
"	float3 v0 = t2.xyz;\n"
"	\n"
"	float3 n1 = mad_cross(e1, e2);\n"
"	float3 n2 = mad_cross(e3, e1);\n"
"	\n"
"	float3 C = v0 - ro;\n"
"	float3 R = mad_cross(rd, C);\n"
"	\n"
"	float det1 = dot(n1, rd);\n"
"	float det2 = dot(n2, rd);\n"
"	\n"
"	int sgnDet1 = as_int(det1) & 0x80000000;\n"
"	int sgnDet2 = as_int(det2) & 0x80000000;\n"
"	\n"
"	int iU1 = as_int( dot(R, e2)) ^ sgnDet1;\n"
"	int iV1 = as_int( dot(R, e1)) ^ sgnDet1;\n"
"	int iU2 = as_int(-dot(R, e1)) ^ sgnDet2;\n"
"	int iV2 = as_int(-dot(R, e3)) ^ sgnDet2;\n"
"	\n"
"	if (((iU1 | iV1) & (iU2 | iV2)) < 0)\n"
"		return tMax;\n"
"	\n"
"	bool outside1 = (iU1 | iV1) < 0;\n"
"	bool outside2 = (iU2 | iV2) < 0;\n"
"	\n"
"	float U1 = as_float(iU1);\n"
"	float V1 = as_float(iV1);\n"
"	float U2 = as_float(iU2);\n"
"	float V2 = as_float(iV2);\n"
"	\n"
"	float absDet1 = fabs(det1);\n"
"	float absDet2 = fabs(det2);\n"
"	\n"
"	float W1 = absDet1 - U1 - V1;\n"
"	float W2 = absDet2 - U2 - V2;\n"
"	\n"
"	float T1 = as_float(as_int(dot(n1, C)) ^ sgnDet1);\n"
"	float T2 = as_float(as_int(dot(n2, C)) ^ sgnDet2);\n"
"	\n"
"	outside1 = outside1 || (W1 < 0.0f || T1 <= absDet1*tNear || T1 > absDet1*tMax);\n"
"	outside2 = outside2 || (W2 < 0.0f || T2 <= absDet2*tNear || T2 > absDet2*tMax);\n"
"	\n"
"	if (outside1 && outside2)\n"
"		return tMax;\n"
"	\n"
"	// At least one triangle was hit. Pick the closest one.\n"
"	index = index*2;\n"
"	\n"
"	if ((!outside2 && outside1) || (!outside1 && !outside2 && T1 * absDet2 > T2 * absDet1)) {\n"
"		// Hit triangle 2.\n"
"		absDet1 = absDet2;\n"
"		T1 = T2;\n"
"		U1 = U2;\n"
"		V1 = V2;\n"
"		\n"
"		++index;\n"
"	}\n"
"	\n"
"	float rcpAbsDet1 = native_recip(absDet1);\n"
"	float t = T1 * rcpAbsDet1;\n"
"	float u = U1 * rcpAbsDet1;\n"
"	float v = V1 * rcpAbsDet1;\n"
"	\n"
"	*hit = make_float4(as_float(index), t, u, v);\n"
"	\n"
"	return t;\n"
"}\n"
"\n"
"inline float aabbIntersect(float3 min, float3 max, float8 ray, float3 invDir, float3 OoD) {\n"
"	float t0 = RAY_NEAR(ray);\n"
"	float t1 = RAY_FAR(ray);\n"
"	\n"
"	// Note: OoD = -origin / dir.\n"
"	float3 tNear = mad(min, invDir, OoD);\n"
"	float3 tFar  = mad(max, invDir, OoD);\n"
"	\n"
"	float3 tMin = fmin(tNear, tFar);\n"
"	float3 tMax = fmax(tNear, tFar);\n"
"	\n"
"	t0 = fmax(fmax(t0, tMin.x), fmax(tMin.y, tMin.z));\n"
"	t1 = fmin(fmin(t1, tMax.x), fmin(tMax.y, tMax.z));\n"
"	\n"
"	if (t0 > t1)\n"
"		return RAY_FAR(ray);\n"
"	\n"
"	return t0;\n"
"}\n"
"\n"
"const sampler_t probeSampler = CLK_NORMALIZED_COORDS_TRUE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_LINEAR;\n"
"\n"
"kernel\n"
"__attribute__((reqd_work_group_size(WORK_GROUP, 1, 1)))\n"
"void traversal(global float8* rays, global float4* nodes, global float4* triangles, global unsigned* triangleIndices, global float4* hits, int count, __read_only image2d_t lightProbe) {\n"
"	int rayIndex = get_global_id(0);\n"
"	\n"
"	if (rayIndex >= count)\n"
"		return;\n"
"	\n"
"	float8 ray = rays[rayIndex];\n"
"	\n"
"	const float epsilon = 1e-10f;\n"
"	if (fabs(RAY_DIRECTION(ray).x) < epsilon)\n"
"		RAY_DIRECTION(ray).x = copysign(epsilon, RAY_DIRECTION(ray).x);\n"
"	\n"
"	if (fabs(RAY_DIRECTION(ray).y) < epsilon)\n"
"		RAY_DIRECTION(ray).y = copysign(epsilon, RAY_DIRECTION(ray).y);\n"
"	\n"
"	if (fabs(RAY_DIRECTION(ray).z) < epsilon)\n"
"		RAY_DIRECTION(ray).z = copysign(epsilon, RAY_DIRECTION(ray).z);\n"
"	\n"
"	float3 invDir = make_float3(1.0f/RAY_DIRECTION(ray).x, 1.0f/RAY_DIRECTION(ray).y, 1.0f/RAY_DIRECTION(ray).z);\n"
"	float3 OoD = -RAY_ORIGIN(ray) * invDir;\n"
"	\n"
"	float4 hit = make_float4(as_float(-1), RAY_FAR(ray), 0.0f, 0.0f);\n"
"	\n"
"	int node = 0x80000000;\n"
"	\n"
"	int stack[64];\n"
"	int stackHead = 0;\n"
"	\n"
"	for (;;) {\n"
"		if (node & 0x80000000) {\n"
"			node &= (~0x80000000);\n"
"			\n"
"			float4 d0 = nodes[node*4 + 0];\n"
"			float4 d1 = nodes[node*4 + 1];\n"
"			float4 d2 = nodes[node*4 + 2];\n"
"			\n"
"			float3 firstMin = d1.xyz;\n"
"			float3 firstMax = make_float3(d1.w, d2.x, d2.y);\n"
"			\n"
"			float tRay = RAY_FAR(ray);\n"
"			float tFirst = aabbIntersect(firstMin, firstMax, ray, invDir, OoD);\n"
"			\n"
"			float4 d3 = nodes[node*4 + 3];\n"
"			\n"
"			float3 lastMin = make_float3(d2.z, d2.w, d3.x);\n"
"			float3 lastMax = make_float3(d3.y, d3.z, d3.w);\n"
"			\n"
"			float tLast = aabbIntersect(lastMin, lastMax, ray, invDir, OoD);\n"
"			\n"
"			float firstDiff = tRay - tFirst;\n"
"			float lastDiff = tRay - tLast;\n"
"			if (firstDiff + lastDiff != 0.0f) {\n"
"				int sgn = signbit(tLast - tFirst);\n"
"				if (fmax(tFirst, tLast) != tRay)\n"
"					stack[stackHead++] = select(as_int(d0.w), as_int(d0.z), sgn);\n"
"				node = select(as_int(d0.z), as_int(d0.w), sgn);\n"
"				continue;\n"
"			}\n"
"		}\n"
"		else {\n"
"			int first = node & 0xffffff;\n"
"			int last = first + (node >> 24);\n"
"			for (int i = first; i < last; ++i)\n"
"				RAY_FAR(ray) = trianglePairIntersect(triangles, i, ray, &hit);\n"
"		}\n"
"		\n"
"		if (!stackHead)\n"
"			break;\n"
"		\n"
"		node = stack[--stackHead];\n"
"	}\n"
"	\n"
"	if (as_int(hit.x) == -1) {\n"
"		float3 d = RAY_DIRECTION(ray);\n"
"		\n"
"		float rlen = native_rsqrt(d.y*d.y + d.z*d.z);\n"
"		float r = (rlen > 1e+6f) ? 0.0f : acos(-d.x)*(1.0f/(2.0f*3.141593f))*rlen;\n"
"		float u = 0.5f - r*d.z;\n"
"		float v = 0.5f - r*d.y;\n"
"		\n"
"		hit.yzw = read_imagef(lightProbe, probeSampler, make_float2(u, v)).xyz;\n"
"	}\n"
"	else {\n"
"		unsigned index = triangleIndices[as_int(hit.x)];\n"
"		\n"
"		// Rotate the barycentric coordinates based on edge.\n"
"		unsigned edge = index >> 30;\n"
"		index &= 0x3fffffff;\n"
"		\n"
"		float3 barys = make_float3(hit.z, hit.w, 1.0f - hit.z - hit.w);\n"
"		\n"
"		if (edge == 1)\n"
"			barys = barys.zxy;\n"
"		else if (edge == 2)\n"
"			barys = barys.yzx;\n"
"		\n"
"		hit.zw = barys.xy;\n"
"		hit.x = as_float(index);\n"
"	}\n"
"	\n"
"	hits[rayIndex] = hit;\n"
"}\n";

static const char clearKernel[] =
"\n"
"kernel\n"
"__attribute__((reqd_work_group_size(8, 1, 1)))\n"
"void clearKernel(global float4* buffer, int count) {\n"
"	int index = get_global_id(0);\n"
"	\n"
"	if (index >= count)\n"
"		return;\n"
"	\n"
"	buffer[index] = (float4){ 0.0f, 0.0f, 0.0f, 0.0f };\n"
"}\n";
